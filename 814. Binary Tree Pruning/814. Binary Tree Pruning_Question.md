We are given the head node root of a binary tree, where additionally every node's value is either a 0 or a 1.

Return the same tree where every subtree (of the given tree) not containing a 1 has been removed.

(Recall that the subtree of a node X is X, plus every node that is a descendant of X.)

**Example 1:**
```
Input: [1,null,0,0,1]
Output: [1,null,0,null,1]

Explanation:
Only the red nodes satisfy the property "every subtree not containing a 1".
The diagram on the right represents the answer.
![image](https://raw.githubusercontent.com/zing9264/LeetCode/master/814.%20Binary%20Tree%20Pruning/1028_2.png)

```
**Example 2:**
```
Input: s = "a)b(c)d"
Output: "ab(c)d"
``` 

**Example 3:**
```
Input: s = "))(("
Output: ""
Explanation: An empty string is also valid.
```
**Example 4:**

```
Input: s = "(a(b(c)d)"
Output: "a(b(c)d)"
```

**Constraints:**

* `1 <= s.length <= 10^5`
* `s[i]` is one of  `'('` , `')'` and lowercase English letters.
